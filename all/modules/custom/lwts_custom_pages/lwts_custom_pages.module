<?php

/**
 * @file
 * Pages specific to LWtS that were prohibitively difficult to do using
 * the Panels module.
 */

// GENERICISE LATER!!!! Don't be trapped in to making very generic fns first

/**
 * Implements hook_menu()
 */
function lwts_custom_pages_menu() {

  $items = array();

  // Home page
  $items['home-page'] = array (
    'title' => 'Home',
    'description' => 'See the latest from Live with the Sea',
    'access callback' => TRUE,
    'page callback' => 'lwts_custom_pages_home_page',
  );

  return $items;
}

/*
  // Get the top level terms from the source vocabulary.
  $top_level_terms = taxonomy_get_tree( $source_vid, 0, 1 );
*/

/**
 * Page callback for the home page.
 */
function lwts_custom_pages_home_page() {

  // No need for a primary topic field when done this way!!!!!

  // Admin vars:
  $sort_property = 'changed';
  $is_sticky_applies = TRUE;
  $vids = array( 2, 3 );

  // Get all nodes of types (article, video), ordered by <sort order> and
  // grouped by stickiness if <sticky applies>.
  $nodes = _lwts_custom_pages_get_node_terms(
    $sort_property,
    $is_sticky_applies,
    $vids
  );

  foreach ( $vids as $vid ) {
    $tree = _lwts_custom_pages_get_vocabulary_tree( $vid );
    dsm( $tree );
  }
  //
  // For each term in the <primary vocab>
  //   remove the first node that is tagged with that term.
  //   output teaser for removed node
  //foreach (
  //
  // For each term in the <secondary vocab>
  //   ditto
  //

  return 'done';
}

/**
 * Get data from nodes tagged with terms from a given set of vocabularies.
 *
 * @todo genericise more - sorting currently restricted to a colum in the
 * node table, which won't work for user ratings or most visited.
 *
 * @param $sort_property_column string
 *   The name of a column in the node table on which to sort
 * @param $is_sticky_applies boolean
 *   Should sticky nodes come at the top of the list?
 * @param $vids array( integer )
 *   The set of vocabulary ids that should be considered.
 * @param $max_nodes integer
 *   The maximum number of nodes to load.
 *
 * @return
 *   array( node_id => array(  ) )
 */
function _lwts_custom_pages_get_node_terms( $sort_property_column, $is_sticky_applies, $vids ) {

  // Tables required:
  // node - nid ( + sort_property )
  // taxonomy_vocabulary - name
  // taxonomy_term_data - to connect vocab to terms
  // taxonomy_index - for node-term join
  //
  $query = db_select( 'node', 'n' );
  $query->join( 'taxonomy_index', 'ti', 'ti.nid = n.nid' );
  $query->join( 'taxonomy_term_data', 'ttd', 'ttd.tid = ti.tid' );
  $query->join( 'taxonomy_vocabulary', 'tv', 'tv.vid = ttd.vid' );
  $query->condition( 'tv.vid', $vids, 'IN' );
  $query->addField( 'n', 'nid', 'node_id' );
  $query->addField( 'ttd', 'tid', 'term_id' );
  $query->addField( 'tv', 'vid', 'vocab_id' );

  if ( $is_sticky_applies ) {
    $query->addField( 'n', 'sticky', 'node_sticky' );
    $query->orderBy( 'node_sticky', 'DESC' );
  }

  $query->addField( 'n', $sort_property_column, 'sort_col' );
  $query->orderBy( 'sort_col', 'DESC' );
  $query->addField( 'ttd', 'weight', 'term_weight' );
  $query->orderBy( 'term_weight', 'ASC' );

  $result_set =  $query->execute();
  $rows = array();
  while ( $row = $result_set->fetchAssoc() ) {
    $rows[ $row['node_id'] ][ $row['term_id'] ] = $row['term_id'];
  }
  return $rows;
}

/**
 * Get the term IDs of a vocabulary keyed by root terms.
 *
 * @param $vid integer
 *   The ID of the required vocabulary
 *
 * @return
 *   array( top_level_tid => array( child_ID ) )
 */
function _lwts_custom_pages_get_vocabulary_tree( $vid ) {

  $terms = taxonomy_get_tree( $vid );
  $branches = array();

  // Collect terms according to parentage
  foreach ( $terms as $term ) {
    $tid = $term->tid;
    $parent = $term->parents[0];  // Assumes single parent!

    if ( empty($branches[$parent]) ) {
      $branches[$parent] = array();
      $branches[$parent]['tid'] = $parent;
      $branches[$parent]['children'] = array();
    }
    $branches[$parent]['children'][$tid] = $tid;
  }

  // Build tree
  $root = $branches['0'];
  unset( $branches['0'] );
  _lwts_custom_pages_assign_child_terms( &$root, &$branches );
  return $root;
}

/**
 * Helper fn to convert terms array to tree.
 *
 * @param $current_term
 *   A term (already inserted in to the tree) that has children.
 *   array( 'tid' => term ID, 'children' => array( term ID of child ) )
 * @param $branches
 *   Array of terms with children, not yet placed in tree.
 */
function _lwts_custom_pages_assign_child_terms( &$current_term, &$branches ) {

  // Iterate through the IDs of the children of the current term.
  foreach ( $current_term['children'] as $child_tid ) {

    // Iterate through the unconnected branches.
    foreach ( $branches as $branch ) {

      // Is the branch a child of the current term?
      if ( $child_tid === $branch['tid'] ) {

        // Move the branch to its place in the heirarchy.
        $current_term['children'][$child_tid] = $branch;
        unset( $branches[$child_tid] );

        if ( !empty( $current_term['children'][$child_tid]['children'] ) ) {
          _lwts_custom_pages_assign_child_terms(
            $current_term['children'][$child_tid], $branches );
        }
      }
    }
  }
}

// HOOK_???? When taxonomy term added or removed from primary or secondary
//      vocab - recalculate column widths - css
//
// Admin settings form. When max columns changes - recalc col widths - css
